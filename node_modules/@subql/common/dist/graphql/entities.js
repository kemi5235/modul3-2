"use strict";
// Copyright 2020-2021 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setJsonObjectType = exports.getAllEntitiesRelations = exports.getAllJsonObjects = void 0;
const assert_1 = __importDefault(require("assert"));
const graphql_1 = require("graphql");
const constant_1 = require("./constant");
const schema_1 = require("./schema");
const types_1 = require("./types");
function getAllJsonObjects(_schema) {
    const schema = typeof _schema === 'string' ? schema_1.buildSchema(_schema) : _schema;
    return Object.values(schema.getTypeMap())
        .filter((node) => { var _a, _b; return (_b = (_a = node.astNode) === null || _a === void 0 ? void 0 : _a.directives) === null || _b === void 0 ? void 0 : _b.find(({ name: { value } }) => value === constant_1.DirectiveName.JsonField); })
        .map((node) => node)
        .filter(graphql_1.isObjectType);
}
exports.getAllJsonObjects = getAllJsonObjects;
function getAllEntitiesRelations(_schema) {
    const schema = typeof _schema === 'string' ? schema_1.buildSchema(_schema) : _schema;
    const entities = Object.values(schema.getTypeMap())
        .filter((node) => { var _a, _b; return (_b = (_a = node.astNode) === null || _a === void 0 ? void 0 : _a.directives) === null || _b === void 0 ? void 0 : _b.find(({ name: { value } }) => value === constant_1.DirectiveName.Entity); })
        .map((node) => node)
        .filter(graphql_1.isObjectType);
    const jsonObjects = getAllJsonObjects(schema);
    const entityNameSet = entities.map((entity) => entity.name);
    const modelRelations = { models: [], relations: [] };
    const derivedFrom = schema.getDirective('derivedFrom');
    const indexDirective = schema.getDirective('index');
    for (const entity of entities) {
        const newModel = {
            name: entity.name,
            fields: [],
            indexes: [],
        };
        for (const field of Object.values(entity.getFields())) {
            const typeString = extractType(field.type).toString();
            const derivedFromDirectValues = graphql_1.getDirectiveValues(derivedFrom, field.astNode);
            //If is a basic scalar type
            if (Object.values(types_1.FieldScalar).includes(typeString)) {
                newModel.fields.push(packEntityField(typeString, field, false));
            }
            // If is a foreign key
            else if (entityNameSet.includes(typeString) && !derivedFromDirectValues) {
                newModel.fields.push(packEntityField(typeString, field, true));
                modelRelations.relations.push({
                    from: entity.name,
                    type: 'belongsTo',
                    to: typeString,
                    foreignKey: `${field.name}Id`,
                });
            }
            // If is derivedFrom
            else if (entityNameSet.includes(typeString) && derivedFromDirectValues) {
                modelRelations.relations.push({
                    from: entity.name,
                    type: graphql_1.isListType(graphql_1.isNonNullType(field.type) ? graphql_1.getNullableType(field.type) : field.type) ? 'hasMany' : 'hasOne',
                    to: typeString,
                    foreignKey: `${derivedFromDirectValues.field}Id`,
                    fieldName: field.name,
                });
            }
            // If is jsonField
            else if (jsonObjects.map((json) => json.name).includes(typeString)) {
                const jsonObject = setJsonObjectType(jsonObjects.find((object) => object.name === typeString), jsonObjects);
                newModel.fields.push(packJSONField(typeString, field, jsonObject));
                newModel.indexes.push({
                    unique: false,
                    fields: [field.name],
                    using: types_1.IndexType.GIN,
                });
            }
            else {
                throw new Error(`${typeString} is not an valid type`);
            }
            // handle indexes
            const indexDirectiveVal = graphql_1.getDirectiveValues(indexDirective, field.astNode);
            if (indexDirectiveVal) {
                if (typeString !== 'ID' && Object.values(types_1.FieldScalar).includes(typeString)) {
                    newModel.indexes.push({
                        unique: indexDirectiveVal.unique,
                        fields: [field.name],
                    });
                }
                else if (typeString !== 'ID' && entityNameSet.includes(typeString)) {
                    newModel.indexes.push({
                        unique: indexDirectiveVal.unique,
                        fields: [`${field.name}Id`],
                        using: types_1.IndexType.HASH,
                    });
                }
                else {
                    throw new Error(`index can not be added on field ${field.name}`);
                }
            }
        }
        modelRelations.models.push(newModel);
    }
    validateRelations(modelRelations);
    return modelRelations;
}
exports.getAllEntitiesRelations = getAllEntitiesRelations;
function packEntityField(typeString, field, isForeignKey) {
    return {
        name: isForeignKey ? `${field.name}Id` : field.name,
        type: isForeignKey ? 'String' : typeString,
        isArray: graphql_1.isListType(graphql_1.isNonNullType(field.type) ? graphql_1.getNullableType(field.type) : field.type),
        nullable: !graphql_1.isNonNullType(field.type),
    };
}
function packJSONField(typeString, field, jsonObject) {
    return {
        name: field.name,
        type: 'Json',
        jsonInterface: jsonObject,
        isArray: graphql_1.isListType(graphql_1.isNonNullType(field.type) ? graphql_1.getNullableType(field.type) : field.type),
        nullable: !graphql_1.isNonNullType(field.type),
    };
}
function setJsonObjectType(jsonObject, jsonObjects) {
    const graphQLJsonObject = {
        name: jsonObject.name,
        fields: [],
    };
    for (const field of Object.values(jsonObject.getFields())) {
        //check if field is also json
        const typeString = extractType(field.type).toString();
        const isJsonType = jsonObjects.map((json) => json.name).includes(typeString);
        graphQLJsonObject.fields.push({
            name: field.name,
            type: isJsonType ? 'Json' : extractType(field.type),
            jsonInterface: isJsonType
                ? setJsonObjectType(jsonObjects.find((object) => object.name === typeString), jsonObjects)
                : undefined,
            nullable: !graphql_1.isNonNullType(field.type),
            isArray: graphql_1.isListType(graphql_1.isNonNullType(field.type) ? graphql_1.getNullableType(field.type) : field.type),
        });
    }
    return graphQLJsonObject;
}
exports.setJsonObjectType = setJsonObjectType;
//Get the type, ready to be convert to string
function extractType(type) {
    const offNullType = graphql_1.isNonNullType(type) ? graphql_1.getNullableType(type) : type;
    const offListType = graphql_1.isListType(offNullType) ? graphql_1.assertListType(offNullType).ofType : type;
    return graphql_1.isNonNullType(offListType) ? graphql_1.getNullableType(offListType) : offListType;
}
function validateRelations(modelRelations) {
    for (const r of modelRelations.relations.filter((model) => model.type === 'hasMany' || model.type === 'hasOne')) {
        assert_1.default(modelRelations.models.find((model) => model.name === r.to && model.fields.find((field) => field.name === r.foreignKey)), `Please check entity ${r.from} with field ${r.fieldName} has correct relation with entity ${r.to}`);
    }
}
//# sourceMappingURL=entities.js.map